*** src/nsterm.h	14 Mar 2009 21:20:08 -0000	1.24
--- src/nsterm.h	15 Mar 2009 20:40:41 -0000
***************
*** 142,150 ****
  - initForView: (EmacsView *)view withIdentifier: (NSString *)identifier;
  - (void) clearActive;
  - (BOOL) changed;
  - (void) addDisplayItemWithImage: (EmacsImage *)img idx: (int)idx
                          helpText: (char *)help
!                          enabled: (BOOL)enabled;
  /* delegate methods */
  - (NSToolbarItem *)toolbar: (NSToolbar *)toolbar
       itemForItemIdentifier: (NSString *)itemIdentifier
--- 142,152 ----
  - initForView: (EmacsView *)view withIdentifier: (NSString *)identifier;
  - (void) clearActive;
  - (BOOL) changed;
+ - (void) addDisplayItemSpacerWithIdx: (int)idx;
  - (void) addDisplayItemWithImage: (EmacsImage *)img idx: (int)idx
                          helpText: (char *)help
! 			enabled: (BOOL)enabled
!       			labelText: (char *)label;
  /* delegate methods */
  - (NSToolbarItem *)toolbar: (NSToolbar *)toolbar
       itemForItemIdentifier: (NSString *)itemIdentifier
*** src/nsmenu.m	6 Mar 2009 19:06:45 -0000	1.21
--- src/nsmenu.m	15 Mar 2009 20:40:40 -0000
***************
*** 75,80 ****
--- 75,82 ----
  static int popup_activated_flag;
  static NSModalSession popupSession;
  
+ Lisp_Object Vns_tool_bar_display_mode;
+ 
  /* NOTE: toolbar implementation is at end,
    following complete menu implementation. */
  
***************
*** 1203,1210 ****
--- 1210,1229 ----
        struct image *img;
        Lisp_Object image;
        Lisp_Object helpObj;
+       Lisp_Object captionObj;
        char *helpText;
+       char *captionText;
+       Lisp_Object label = TOOLPROP (TOOL_BAR_ITEM_CAPTION);
+  
+       if (strcmp("--", SDATA (label)) == 0)
+   {
+ 
+       [toolbar addDisplayItemSpacerWithIdx: i ];
+   }
+  else
+    {
  
+  
        /* If image is a vector, choose the image according to the
  	 button state.  */
        image = TOOLPROP (TOOL_BAR_ITEM_IMAGES);
***************
*** 1241,1250 ****
          helpObj = TOOLPROP (TOOL_BAR_ITEM_CAPTION);
        helpText = NILP (helpObj) ? "" : (char *)SDATA (helpObj);
  
        [toolbar addDisplayItemWithImage: img->pixmap idx: i helpText: helpText
!                                enabled: enabled_p];
  #undef TOOLPROP
      }
  
    if (![toolbar isVisible])
        [toolbar setVisible: YES];
--- 1260,1283 ----
          helpObj = TOOLPROP (TOOL_BAR_ITEM_CAPTION);
        helpText = NILP (helpObj) ? "" : (char *)SDATA (helpObj);
  
+       captionObj = TOOLPROP (TOOL_BAR_ITEM_CAPTION);
+       captionText = NILP (captionObj) ? "" : (char *)SDATA (captionObj);
+ 
        [toolbar addDisplayItemWithImage: img->pixmap idx: i helpText: helpText
! 	       enabled: enabled_p  labelText: captionText];
  #undef TOOLPROP
      }
+     }
+ 
+   /* set correct tool-bar height because x_set_window_size can't do it
+      before the tool-bar has been drawn. */
+ 
+   // EmacsView *view = FRAME_NS_VIEW (f);
+   // NSWindow *window = [view window];
+   // FRAME_NS_TOOLBAR_HEIGHT (f) = 
+   //   NSHeight ([window frameRectForContentRect: NSMakeRect (0, 0, 0, 0)])
+   //   - FRAME_NS_TITLEBAR_HEIGHT (f);
+ 
  
    if (![toolbar isVisible])
        [toolbar setVisible: YES];
***************
*** 1286,1292 ****
  {
    self = [super initWithIdentifier: identifier];
    emacsView = view;
!   [self setDisplayMode: NSToolbarDisplayModeIconOnly];
    [self setSizeMode: NSToolbarSizeModeSmall];
    [self setDelegate: self];
    identifierToItem = [[NSMutableDictionary alloc] initWithCapacity: 10];
--- 1322,1328 ----
  {
    self = [super initWithIdentifier: identifier];
    emacsView = view;
!   [self setDisplayMode: NSToolbarDisplayModeDefault];
    [self setSizeMode: NSToolbarSizeModeSmall];
    [self setDelegate: self];
    identifierToItem = [[NSMutableDictionary alloc] initWithCapacity: 10];
***************
*** 1310,1315 ****
--- 1346,1364 ----
    [activeIdentifiers removeAllObjects];
    prevEnablement = enablement;
    enablement = 0L;
+ 
+   if (EQ (Vns_tool_bar_display_mode, intern ("labels")))
+     {
+       [self setDisplayMode: NSToolbarDisplayModeIconAndLabel];
+     }
+   else if (EQ (Vns_tool_bar_display_mode, intern ("icons")))
+     {
+       [self setDisplayMode: NSToolbarDisplayModeIconOnly];
+     }
+   else
+     {
+       [self setDisplayMode: NSToolbarDisplayModeDefault];
+     } 
  }
  
  - (BOOL) changed
***************
*** 1318,1325 ****
--- 1367,1396 ----
      enablement == prevEnablement ? NO : YES;
  }
  
+ - (void) addDisplayItemSpacerWithIdx: (int)idx
+ {
+   /* 1) come up w/identifier */
+   NSString *identifier = NSToolbarFlexibleSpaceItemIdentifier;
+ 
+   /* 2) create / reuse item */
+   NSToolbarItem *item = [identifierToItem objectForKey: identifier];
+   if (item == nil)
+     {
+       item = [[[NSToolbarItem alloc] initWithItemIdentifier: identifier]
+                autorelease];
+     }
+ 
+   //  [item setTag: idx];  can't do because more than one flex space item may be present
+ 
+   /* 3) update state */
+   [identifierToItem setObject: item forKey: identifier];
+   [activeIdentifiers addObject: identifier];
+   enablement = (enablement << 1) | false;
+ }
+ 
  - (void) addDisplayItemWithImage: (EmacsImage *)img idx: (int)idx
                          helpText: (char *)help enabled: (BOOL)enabled
+ 		       labelText: (char *)label;
  {
    /* 1) come up w/identifier */
    NSString *identifier
***************
*** 1333,1338 ****
--- 1404,1410 ----
                 autorelease];
        [item setImage: img];
        [item setToolTip: [NSString stringWithCString: help]];
+       [item setLabel: [NSString stringWithCString: label]];
        [item setTarget: emacsView];
        [item setAction: @selector (toolbarClicked:)];
      }
***************
*** 1909,1914 ****
--- 1991,1997 ----
  
     ========================================================================== */
  
+ 
  DEFUN ("ns-reset-menu", Fns_reset_menu, Sns_reset_menu, 0, 0, 0,
         doc: /* Cause the NS menu to be re-calculated.  */)
       ()
***************
*** 2003,2008 ****
--- 2086,2103 ----
  void
  syms_of_nsmenu ()
  {
+ 
+ 
+   DEFVAR_LISP ("ns-tool-bar-display-mode", &Vns_tool_bar_display_mode,
+      doc: /* *Specify whether to display the tool bar as icons with labels.
+ The value can be `icons' (for icons only), `labels' (for icons with labels)
+ and nil, in which case the system default is assumed.
+ The default is nil.  */);
+ 
+   Vns_tool_bar_display_mode = Qnil;
+ 
+ 
+ 
    defsubr (&Sx_popup_menu);
    defsubr (&Sx_popup_dialog);
    defsubr (&Sns_reset_menu);
*** lisp/tool-bar.el	10 Jan 2009 09:51:31 -0000	1.24
--- lisp/tool-bar.el	15 Mar 2009 20:28:25 -0000
***************
*** 54,69 ****
    :group 'frames
    (if tool-bar-mode
        (progn
! 	;; Make one tool-bar-line for any - including non-graphical -
! 	;; terminal, see Bug#1754.  If this causes problems, we should
! 	;; handle the problem in `modify-frame-parameters' or do not
! 	;; call `modify-all-frames-parameters' when toggling the tool
! 	;; bar off either.
! 	(modify-all-frames-parameters (list (cons 'tool-bar-lines 1)))
  	(if (= 1 (length (default-value 'tool-bar-map))) ; not yet setup
  	    (tool-bar-setup)))
      (modify-all-frames-parameters (list (cons 'tool-bar-lines 0)))))
  
  ;;;###autoload
  ;; Used in the Show/Hide menu, to have the toggle reflect the current frame.
  (defun toggle-tool-bar-mode-from-frame (&optional arg)
--- 54,137 ----
    :group 'frames
    (if tool-bar-mode
        (progn
!   	(modify-all-frames-parameters (list (cons 'tool-bar-lines 1)))
  	(if (= 1 (length (default-value 'tool-bar-map))) ; not yet setup
  	    (tool-bar-setup)))
      (modify-all-frames-parameters (list (cons 'tool-bar-lines 0)))))
  
+ (defun tool-bar-set-file-extension (image-spec-list extension)
+   "Set new file extensions for all :file properties
+ Replace any extensions of :file properties in elements of
+ IMAGE-SPEC-LIST. An extension may start with a period . or an
+ underscore. EXTENSION and the original file name extension (starting
+ with a period) are added to the file name.
+ 
+ E.g. foo_dis.xpm becomes foo_sel.xpm if EXTENSION is '_sel'."
+   (mapcar
+    (lambda (spec) 
+      (let ((f (plist-get spec :file)) 
+ 	    )
+         (if (null f)
+ 	    spec
+ 	  ;; need to replace previous extensions, including those
+ 	  ;; starting with _ - 
+ 	  (plist-put spec :file (concat (replace-regexp-in-string "[\.\_].*$" 
+ 								  "" f)
+ 					extension 
+ 					(file-name-extension f t)))
+ 	  )))
+    image-spec-list))
+ 
+ (defun tool-bar-get-image-spec (icon)
+   (let* ((fg (face-attribute 'tool-bar :foreground))
+ 	 (bg (face-attribute 'tool-bar :background))
+ 	 (colors (nconc (if (eq fg 'unspecified) nil (list :foreground fg))
+ 			(if (eq bg 'unspecified) nil (list :background bg))))
+ 	 (xpm-spec (list :type 'xpm :file (concat icon ".xpm")))
+ 	 (xpm-lo-spec (if (> (display-color-cells) 256)
+ 			  nil
+ 			(list :type 'xpm :file
+                               (concat "low-color/" icon ".xpm"))))
+ 	 (png-spec (if (image-type-available-p 'png)
+ 		       (list :type 'png :file (concat icon ".png") 
+ 			     :background "grey")))
+ 	 (pbm-spec (append (list :type 'pbm :file
+                                  (concat icon ".pbm")) colors))
+ 	 (xbm-spec (append (list :type 'xbm :file
+                                  (concat icon ".xbm")) colors))
+ 	 (image (find-image
+ 		(if (display-color-p)
+ 		    (list png-spec xpm-lo-spec xpm-spec pbm-spec xbm-spec)
+ 		  (list pbm-spec xbm-spec xpm-lo-spec xpm-spec))))
+ 	 (image-sel (find-image
+ 		     (if (display-color-p)
+ 			 (tool-bar-set-file-extension
+ 			  (list png-spec xpm-lo-spec xpm-spec pbm-spec xbm-spec)
+ 			  "_sel")
+ 		       nil)))
+ 	 (image-dis (find-image
+ 		     (if (display-color-p)
+ 			 (tool-bar-set-file-extension
+ 			  (list png-spec xpm-lo-spec xpm-spec pbm-spec xbm-spec)
+ 			  "_dis")
+ 		       nil)))
+ 	 (images (when image ;; image may be nil if not found.
+ 		   ;; batch-compiling may lead to non-existant frames,
+ 		   ;; in which case image-mask-p will fail.
+ 		    (unless (condition-case nil (image-mask-p image) (error t))
+  		     (setq image (append image '(:mask heuristic))))
+ 		   (if (and image-sel image-dis)
+ 		       (progn		     
+ 			 (unless (condition-case nil (image-mask-p image-sel) (error t))
+ 			   (setq image-sel (append image-sel 
+ 						   '(:mask heuristic))))
+ 			 (unless (condition-case nil (image-mask-p image-dis) (error t))
+ 			   (setq image-dis (append image-dis 
+ 						   '(:mask heuristic))))
+ 			 (vector image-sel image image-dis image-dis))
+ 		     image)))) 
+     (cons image images)))
+ 
  ;;;###autoload
  ;; Used in the Show/Hide menu, to have the toggle reflect the current frame.
  (defun toggle-tool-bar-mode-from-frame (&optional arg)
***************
*** 121,127 ****
  		(if (not (display-images-p))
  		    (setq bind nil)
  		  (let ((image (eval image-exp)))
! 		    (unless (and image (image-mask-p image))
  		      (setq image (append image '(:mask heuristic))))
  		    (setq bind (copy-sequence bind)
  			  plist (nthcdr (if (consp (nth 4 bind)) 5 4)
--- 189,196 ----
  		(if (not (display-images-p))
  		    (setq bind nil)
  		  (let ((image (eval image-exp)))
! 		    (unless (and image 
! 				 (condition-case nil (image-mask-p image) (error t)))
  		      (setq image (append image '(:mask heuristic))))
  		    (setq bind (copy-sequence bind)
  			  plist (nthcdr (if (consp (nth 4 bind)) 5 4)
***************
*** 150,184 ****
  ;;;###autoload
  (defun tool-bar-local-item (icon def key map &rest props)
    "Add an item to the tool bar in map MAP.
! ICON names the image, DEF is the key definition and KEY is a symbol
! for the fake function key in the menu keymap.  Remaining arguments
! PROPS are additional items to add to the menu item specification.  See
! Info node `(elisp)Tool Bar'.  Items are added from left to right.
! 
! ICON is the base name of a file containing the image to use.  The
! function will first try to use low-color/ICON.xpm if `display-color-cells'
! is less or equal to 256, then ICON.xpm, then ICON.pbm, and finally
! ICON.xbm, using `find-image'."
!   (let* ((fg (face-attribute 'tool-bar :foreground))
! 	 (bg (face-attribute 'tool-bar :background))
! 	 (colors (nconc (if (eq fg 'unspecified) nil (list :foreground fg))
! 			(if (eq bg 'unspecified) nil (list :background bg))))
! 	 (xpm-spec (list :type 'xpm :file (concat icon ".xpm")))
! 	 (xpm-lo-spec (list :type 'xpm :file
! 			    (concat "low-color/" icon ".xpm")))
! 	 (pbm-spec (append (list :type 'pbm :file
!                                  (concat icon ".pbm")) colors))
! 	 (xbm-spec (append (list :type 'xbm :file
!                                  (concat icon ".xbm")) colors))
! 	 (image-exp `(find-image
! 		      (cond ((not (display-color-p))
! 			     ',(list pbm-spec xbm-spec xpm-lo-spec xpm-spec))
! 			    ((< (display-color-cells) 256)
! 			     ',(list xpm-lo-spec xpm-spec pbm-spec xbm-spec))
! 			    (t
! 			     ',(list xpm-spec pbm-spec xbm-spec))))))
!     (define-key-after map (vector key)
!       `(menu-item ,(symbol-name key) ,def :image ,image-exp ,@props))))
  
  ;;;###autoload
  (defun tool-bar-add-item-from-menu (command icon &optional map &rest props)
--- 219,247 ----
  ;;;###autoload
  (defun tool-bar-local-item (icon def key map &rest props)
    "Add an item to the tool bar in map MAP.
! ICON names the image, or is structure of the form (IMG . LABEL),
! with the image name IMG, and a string with the label of the icon
! displayed in the tool-bar as LABEL. LABEL defaults to the symbol
! name of KEY.  DEF is the key definition and KEY is a symbol for
! the fake function key in the menu keymap Remaining arguments
! PROPS are additional items to add to the menu item specification.
! See Info node `(elisp)Tool Bar'. Items are added from left to
! right.
! 
! ICON or IMG is the base name of a file containing the image to
! use. The function will first try to use low-color/ICON.xpm if
! display-color-cells is less or equal to 256, then ICON.xpm, then
! ICON.pbm, and finally ICON.xbm, using `find-image'."
!   (let* ((icon-name (if (consp icon) (car icon) icon))
! 	 (label (if (consp icon) (cdr icon) ""))
! 	 (is (tool-bar-get-image-spec icon-name))
! 	 (image (car is))
! 	 (images (cdr is))) 
!     (when (and (display-images-p) image)
!       (define-key-after map (vector key)
! 	`(menu-item ,label 
! 		    ,def :image ,images ,@props)))))
!   
  
  ;;;###autoload
  (defun tool-bar-add-item-from-menu (command icon &optional map &rest props)
***************
*** 199,322 ****
  ;;;###autoload
  (defun tool-bar-local-item-from-menu (command icon in-map &optional from-map &rest props)
    "Define local tool bar binding for COMMAND using the given ICON.
! This makes a binding for COMMAND in IN-MAP, copying its binding from
! the menu bar in FROM-MAP (which defaults to `global-map'), but
! modifies the binding by adding an image specification for ICON.  It
! finds ICON just like `tool-bar-add-item'.  PROPS are additional
  properties to add to the binding.
! 
  FROM-MAP must contain appropriate binding for `[menu-bar]' which
  holds a keymap."
    (unless from-map
      (setq from-map global-map))
!   (let* ((menu-bar-map (lookup-key from-map [menu-bar]))
! 	 (keys (where-is-internal command menu-bar-map))
! 	 (fg (face-attribute 'tool-bar :foreground))
! 	 (bg (face-attribute 'tool-bar :background))
! 	 (colors (nconc (if (eq fg 'unspecified) nil (list :foreground fg))
! 			(if (eq bg 'unspecified) nil (list :background bg))))
! 	 (xpm-spec (list :type 'xpm :file (concat icon ".xpm")))
! 	 (xpm-lo-spec (list :type 'xpm :file
! 			    (concat "low-color/" icon ".xpm")))
! 	 (pbm-spec (append (list :type 'pbm :file
!                                  (concat icon ".pbm")) colors))
! 	 (xbm-spec (append (list :type 'xbm :file
!                                  (concat icon ".xbm")) colors))
! 	 (image-exp `(find-image
! 		      (cond ((not (display-color-p))
! 			     ',(list pbm-spec xbm-spec xpm-lo-spec xpm-spec))
! 			    ((< (display-color-cells) 256)
! 			     ',(list xpm-lo-spec xpm-spec pbm-spec xbm-spec))
! 			    (t
! 			     ',(list xpm-spec pbm-spec xbm-spec)))))
! 	 submap key)
!     ;; We'll pick up the last valid entry in the list of keys if
!     ;; there's more than one.
!     (dolist (k keys)
!       ;; We're looking for a binding of the command in a submap of
!       ;; the menu bar map, so the key sequence must be two or more
!       ;; long.
!       (if (and (vectorp k)
!                (> (length k) 1))
!           (let ((m (lookup-key menu-bar-map (substring k 0 -1)))
!                 ;; Last element in the bound key sequence:
!                 (kk (aref k (1- (length k)))))
!             (if (and (keymapp m)
!                      (symbolp kk))
!                 (setq submap m
!                       key kk)))))
!     (when (and (symbolp submap) (boundp submap))
!       (setq submap (eval submap)))
!     (let ((defn (assq key (cdr submap))))
!       (if (eq (cadr defn) 'menu-item)
!           (define-key-after in-map (vector key)
!             (append (cdr defn) (list :image image-exp) props))
!         (setq defn (cdr defn))
!         (define-key-after in-map (vector key)
!           (let ((rest (cdr defn)))
!             ;; If the rest of the definition starts
!             ;; with a list of menu cache info, get rid of that.
!             (if (and (consp rest) (consp (car rest)))
!                 (setq rest (cdr rest)))
!             (append `(menu-item ,(car defn) ,rest)
!                     (list :image image-exp) props)))))))
  
  ;;; Set up some global items.  Additions/deletions up for grabs.
  
! (defun tool-bar-setup ()
!   ;; People say it's bad to have EXIT on the tool bar, since users
!   ;; might inadvertently click that button.
!   ;;(tool-bar-add-item-from-menu 'save-buffers-kill-emacs "exit")
!   (tool-bar-add-item-from-menu 'find-file "new")
!   (tool-bar-add-item-from-menu 'menu-find-file-existing "open")
!   (tool-bar-add-item-from-menu 'dired "diropen")
!   (tool-bar-add-item-from-menu 'kill-this-buffer "close")
!   (tool-bar-add-item-from-menu 'save-buffer "save" nil
! 			       :visible '(or buffer-file-name
! 					     (not (eq 'special
! 						      (get major-mode
! 							   'mode-class)))))
!   (tool-bar-add-item-from-menu 'write-file "saveas" nil
! 			       :visible '(or buffer-file-name
! 					     (not (eq 'special
! 						      (get major-mode
! 							   'mode-class)))))
!   (tool-bar-add-item-from-menu 'undo "undo" nil
! 			       :visible '(not (eq 'special (get major-mode
! 								'mode-class))))
!   (tool-bar-add-item-from-menu (lookup-key menu-bar-edit-menu [cut])
! 			       "cut" nil
! 			       :visible '(not (eq 'special (get major-mode
! 								'mode-class))))
!   (tool-bar-add-item-from-menu (lookup-key menu-bar-edit-menu [copy])
! 			       "copy")
!   (tool-bar-add-item-from-menu (lookup-key menu-bar-edit-menu [paste])
! 			       "paste" nil
! 			       :visible '(not (eq 'special (get major-mode
! 								'mode-class))))
!   (tool-bar-add-item-from-menu 'nonincremental-search-forward "search")
!   ;;(tool-bar-add-item-from-menu 'ispell-buffer "spell")
! 
!   ;; There's no icon appropriate for News and we need a command rather
!   ;; than a lambda for Read Mail.
!   ;;(tool-bar-add-item-from-menu 'compose-mail "mail/compose")
! 
!   (tool-bar-add-item-from-menu 'print-buffer "print")
! 
!   ;; tool-bar-add-item-from-menu itself operates on
!   ;; (default-value 'tool-bar-map), but when we don't use that function,
!   ;; we must explicitly operate on the default value.
! 
!   (let ((tool-bar-map (default-value 'tool-bar-map)))
!     (tool-bar-add-item "preferences" 'customize 'customize
! 		       :help "Edit preferences (customize)")
! 
!     (tool-bar-add-item "help" (lambda ()
! 				(interactive)
! 				(popup-menu menu-bar-help-menu))
! 		       'help
! 		       :help "Pop up the Help menu")))
! 
  
  (provide 'tool-bar)
  ;; arch-tag: 15f30f0a-d0d7-4d50-bbb7-f48fd0c8582f
--- 262,382 ----
  ;;;###autoload
  (defun tool-bar-local-item-from-menu (command icon in-map &optional from-map &rest props)
    "Define local tool bar binding for COMMAND using the given ICON.
! ICON names the image, or is structure of the form (IMG . LABEL),
! with the image name IMG, and a string with the label of the icon
! displyed in the tool-bar as LABEL. This function creates a
! binding for COMMAND in IN-MAP, copying its binding from the menu
! bar in FROM-MAP (which defaults to `global-map'), but modifies
! the binding by adding an image specification for ICON. It finds
! ICON just like `tool-bar-add-item'. PROPS are additional
  properties to add to the binding.
!   
  FROM-MAP must contain appropriate binding for `[menu-bar]' which
  holds a keymap."
    (unless from-map
      (setq from-map global-map))
!   (let* ((icon-name (if (consp icon) (car icon) icon))
! 	 (label (if (consp icon) (cdr icon)))
! 	 (menu-bar-map (lookup-key from-map [menu-bar]))
!   	 (keys (where-is-internal command menu-bar-map))
! 	 (is (tool-bar-get-image-spec icon-name))
! 	 (image (car is))
! 	 (images (cdr is)) 
!   	 submap key)
!     (when (and (display-images-p) image)
!       ;; We'll pick up the last valid entry in the list of keys if
!       ;; there's more than one.
!       (dolist (k keys)
! 	;; We're looking for a binding of the command in a submap of
! 	;; the menu bar map, so the key sequence must be two or more
! 	;; long.
! 	(if (and (vectorp k)
! 		 (> (length k) 1))
! 	    (let ((m (lookup-key menu-bar-map (substring k 0 -1)))
! 		  ;; Last element in the bound key sequence:
! 		  (kk (aref k (1- (length k)))))
! 	      (if (and (keymapp m)
! 		       (symbolp kk))
! 		  (setq submap m
! 			key kk)))))
!       (when (and (symbolp submap) (boundp submap))
! 	(setq submap (eval submap)))
!       (let ((defn (assq key (cdr submap))))
! 	(if (eq (cadr defn) 'menu-item)
! 	    (define-key-after in-map (vector key)
! 	      (append `(menu-item ,(or label (car (cddr defn)))) (cdr (cddr defn))
! 		      (list :image image) props))
! 	  (setq defn (cdr defn))
! 	  (define-key-after in-map (vector key)
! 	    (let ((rest (cdr defn)))
! 	      ;; If the rest of the definition starts
! 	      ;; with a list of menu cache info, get rid of that.
! 	      (if (and (consp rest) (consp (car rest)))
! 		  (setq rest (cdr rest)))
! 	      (append `(menu-item ,(or label (car defn)) ,rest)
! 		      (list :image image) props))))))))
  
  ;;; Set up some global items.  Additions/deletions up for grabs.
  
! (setq tool-bar-setup nil)
! ;; (tool-bar-setup)
! (defun tool-bar-setup (&optional frame)
!   (unless tool-bar-setup
!     (with-selected-frame
!      (or frame (selected-frame))
!      ;; People say it's bad to have EXIT on the tool bar, since users
!      ;; might inadvertently click that button.
!      ;;(tool-bar-add-item-from-menu 'save-buffers-kill-emacs "exit")
!      (tool-bar-add-item-from-menu 'find-file '("new" . "New"))
!      (tool-bar-add-item-from-menu 'menu-find-file-existing '("open" . "Open"))
!      (tool-bar-add-item-from-menu 'dired '("diropen" . "Directory"))
!      (tool-bar-add-item-from-menu 'kill-this-buffer "close")
!      (tool-bar-add-item-from-menu 'save-buffer '("save" . "Save") nil
! 				  :visible '(or buffer-file-name
! 						(not (eq 'special
! 							 (get major-mode
! 							      'mode-class)))))
!      (tool-bar-add-item-from-menu 'write-file '("saveas" . "Save As") nil
! 				  :visible '(or buffer-file-name
! 						(not (eq 'special
! 							 (get major-mode
! 							      'mode-class)))))
!      (tool-bar-add-item-from-menu 'undo "undo" nil
! 				  :visible '(not (eq 'special (get major-mode
! 								   'mode-class))))
!      (tool-bar-add-item-from-menu (lookup-key menu-bar-edit-menu [cut])
! 				  "cut" nil
! 				  :visible '(not (eq 'special (get major-mode
! 								   'mode-class))))
!      (tool-bar-add-item-from-menu (lookup-key menu-bar-edit-menu [copy])
! 				  "copy")
!      (tool-bar-add-item-from-menu (lookup-key menu-bar-edit-menu [paste])
! 				  "paste" nil
! 				  :visible '(not (eq 'special (get major-mode
! 								   'mode-class))))
!      (tool-bar-add-item-from-menu 'nonincremental-search-forward "search")
!      ;;(tool-bar-add-item-from-menu 'ispell-buffer "spell")
! 
!      ;; There's no icon appropriate for News and we need a command rather
!      ;; than a lambda for Read Mail.
!      ;;(tool-bar-add-item-from-menu 'compose-mail "mail/compose")
! 
!      (tool-bar-add-item-from-menu 'print-buffer "print")
! 
!      ;; tool-bar-add-item-from-menu itself operates on
!      ;; (default-value 'tool-bar-map), but when we don't use that function,
!      ;; we must explicitly operate on the default value.
! 
!      (let ((tool-bar-map (default-value 'tool-bar-map)))
!        (tool-bar-add-item '("preferences" . "Customize") 'customize 'customize
! 			  :help "Edit preferences (customize)")
! 
!        (tool-bar-add-item '("help" . "Help") (lambda ()
! 					       (interactive)
! 					       (popup-menu menu-bar-help-menu))
! 			  'help
! 			  :help "Pop up the Help menu"))
!      (setq tool-bar-setup t))))
  
  (provide 'tool-bar)
  ;; arch-tag: 15f30f0a-d0d7-4d50-bbb7-f48fd0c8582f
