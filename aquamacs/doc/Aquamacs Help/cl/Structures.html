<html lang="en">
<head>
<title>Structures - Common Lisp Extensions</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Common Lisp Extensions">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Lists.html#Lists" title="Lists">
<link rel="next" href="Assertions.html#Assertions" title="Assertions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents the GNU Emacs Common Lisp emulation package.

Copyright (C) 1993, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
2008, 2009, 2010  Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being ``A GNU Manual'', and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Structures"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Assertions.html#Assertions">Assertions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Lists.html#Lists">Lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">12 Structures</h2>

<p class="noindent">The Common Lisp <dfn>structure</dfn> mechanism provides a general way
to define data types similar to C's <code>struct</code> types.  A
structure is a Lisp object containing some number of <dfn>slots</dfn>,
each of which can hold any Lisp data object.  Functions are
provided for accessing and setting the slots, creating or copying
structure objects, and recognizing objects of a particular structure
type.

   <p>In true Common Lisp, each structure type is a new type distinct
from all existing Lisp types.  Since the underlying Emacs Lisp
system provides no way to create new distinct types, this package
implements structures as vectors (or lists upon request) with a
special &ldquo;tag&rdquo; symbol to identify them.

<div class="defun">
&mdash; Special Form: <b>defstruct</b><var> name slots<small class="dots">...</small><a name="index-defstruct-181"></a></var><br>
<blockquote><p>The <code>defstruct</code> form defines a new structure type called
<var>name</var>, with the specified <var>slots</var>.  (The <var>slots</var>
may begin with a string which documents the structure type.) 
In the simplest case, <var>name</var> and each of the <var>slots</var>
are symbols.  For example,

     <pre class="example">          (defstruct person name age sex)
</pre>
        <p class="noindent">defines a struct type called <code>person</code> which contains three
slots.  Given a <code>person</code> object <var>p</var>, you can access those
slots by calling <code>(person-name </code><var>p</var><code>)</code>, <code>(person-age </code><var>p</var><code>)</code>,
and <code>(person-sex </code><var>p</var><code>)</code>.  You can also change these slots by
using <code>setf</code> on any of these place forms:

     <pre class="example">          (incf (person-age birthday-boy))
</pre>
        <p>You can create a new <code>person</code> by calling <code>make-person</code>,
which takes keyword arguments <code>:name</code>, <code>:age</code>, and
<code>:sex</code> to specify the initial values of these slots in the
new object.  (Omitting any of these arguments leaves the corresponding
slot &ldquo;undefined,&rdquo; according to the Common Lisp standard; in Emacs
Lisp, such uninitialized slots are filled with <code>nil</code>.)

        <p>Given a <code>person</code>, <code>(copy-person </code><var>p</var><code>)</code> makes a new
object of the same type whose slots are <code>eq</code> to those of <var>p</var>.

        <p>Given any Lisp object <var>x</var>, <code>(person-p </code><var>x</var><code>)</code> returns
true if <var>x</var> looks like a <code>person</code>, false otherwise.  (Again,
in Common Lisp this predicate would be exact; in Emacs Lisp the
best it can do is verify that <var>x</var> is a vector of the correct
length which starts with the correct tag symbol.)

        <p>Accessors like <code>person-name</code> normally check their arguments
(effectively using <code>person-p</code>) and signal an error if the
argument is the wrong type.  This check is affected by
<code>(optimize (safety ...))</code> declarations.  Safety level 1,
the default, uses a somewhat optimized check that will detect all
incorrect arguments, but may use an uninformative error message
(e.g., &ldquo;expected a vector&rdquo; instead of &ldquo;expected a <code>person</code>&rdquo;). 
Safety level 0 omits all checks except as provided by the underlying
<code>aref</code> call; safety levels 2 and 3 do rigorous checking that will
always print a descriptive error message for incorrect inputs. 
See <a href="Declarations.html#Declarations">Declarations</a>.

     <pre class="example">          (setq dave (make-person :name "Dave" :sex 'male))
               &rArr; [cl-struct-person "Dave" nil male]
          (setq other (copy-person dave))
               &rArr; [cl-struct-person "Dave" nil male]
          (eq dave other)
               &rArr; nil
          (eq (person-name dave) (person-name other))
               &rArr; t
          (person-p dave)
               &rArr; t
          (person-p [1 2 3 4])
               &rArr; nil
          (person-p "Bogus")
               &rArr; nil
          (person-p '[cl-struct-person counterfeit person object])
               &rArr; t
</pre>
        <p>In general, <var>name</var> is either a name symbol or a list of a name
symbol followed by any number of <dfn>struct options</dfn>; each <var>slot</var>
is either a slot symbol or a list of the form &lsquo;<samp><span class="samp">(</span><var>slot-name</var>
<var>default-value</var> <var>slot-options</var><span class="samp">...)</span></samp>&rsquo;.  The <var>default-value</var>
is a Lisp form which is evaluated any time an instance of the
structure type is created without specifying that slot's value.

        <p>Common Lisp defines several slot options, but the only one
implemented in this package is <code>:read-only</code>.  A non-<code>nil</code>
value for this option means the slot should not be <code>setf</code>-able;
the slot's value is determined when the object is created and does
not change afterward.

     <pre class="example">          (defstruct person
            (name nil :read-only t)
            age
            (sex 'unknown))
</pre>
        <p>Any slot options other than <code>:read-only</code> are ignored.

        <p>For obscure historical reasons, structure options take a different
form than slot options.  A structure option is either a keyword
symbol, or a list beginning with a keyword symbol possibly followed
by arguments.  (By contrast, slot options are key-value pairs not
enclosed in lists.)

     <pre class="example">          (defstruct (person (:constructor create-person)
                             (:type list)
                             :named)
            name age sex)
</pre>
        <p>The following structure options are recognized.

          <dl>
<dt><code>:conc-name</code><dd>The argument is a symbol whose print name is used as the prefix for
the names of slot accessor functions.  The default is the name of
the struct type followed by a hyphen.  The option <code>(:conc-name p-)</code>
would change this prefix to <code>p-</code>.  Specifying <code>nil</code> as an
argument means no prefix, so that the slot names themselves are used
to name the accessor functions.

          <br><dt><code>:constructor</code><dd>In the simple case, this option takes one argument which is an
alternate name to use for the constructor function.  The default
is <code>make-</code><var>name</var>, e.g., <code>make-person</code>.  The above
example changes this to <code>create-person</code>.  Specifying <code>nil</code>
as an argument means that no standard constructor should be
generated at all.

          <p>In the full form of this option, the constructor name is followed
by an arbitrary argument list.  See <a href="Program-Structure.html#Program-Structure">Program Structure</a>, for a
description of the format of Common Lisp argument lists.  All
options, such as <code>&amp;rest</code> and <code>&amp;key</code>, are supported. 
The argument names should match the slot names; each slot is
initialized from the corresponding argument.  Slots whose names
do not appear in the argument list are initialized based on the
<var>default-value</var> in their slot descriptor.  Also, <code>&amp;optional</code>
and <code>&amp;key</code> arguments which don't specify defaults take their
defaults from the slot descriptor.  It is valid to include arguments
which don't correspond to slot names; these are useful if they are
referred to in the defaults for optional, keyword, or <code>&amp;aux</code>
arguments which <em>do</em> correspond to slots.

          <p>You can specify any number of full-format <code>:constructor</code>
options on a structure.  The default constructor is still generated
as well unless you disable it with a simple-format <code>:constructor</code>
option.

          <pre class="example">               (defstruct
                (person
                 (:constructor nil)   ; no default constructor
                 (:constructor new-person (name sex &amp;optional (age 0)))
                 (:constructor new-hound (&amp;key (name "Rover")
                                               (dog-years 0)
                                          &amp;aux (age (* 7 dog-years))
                                               (sex 'canine))))
                name age sex)
</pre>
          <p>The first constructor here takes its arguments positionally rather
than by keyword.  (In official Common Lisp terminology, constructors
that work By Order of Arguments instead of by keyword are called
&ldquo;BOA constructors.&rdquo;  No, I'm not making this up.)  For example,
<code>(new-person "Jane" 'female)</code> generates a person whose slots
are <code>"Jane"</code>, 0, and <code>female</code>, respectively.

          <p>The second constructor takes two keyword arguments, <code>:name</code>,
which initializes the <code>name</code> slot and defaults to <code>"Rover"</code>,
and <code>:dog-years</code>, which does not itself correspond to a slot
but which is used to initialize the <code>age</code> slot.  The <code>sex</code>
slot is forced to the symbol <code>canine</code> with no syntax for
overriding it.

          <br><dt><code>:copier</code><dd>The argument is an alternate name for the copier function for
this type.  The default is <code>copy-</code><var>name</var>.  <code>nil</code>
means not to generate a copier function.  (In this implementation,
all copier functions are simply synonyms for <code>copy-sequence</code>.)

          <br><dt><code>:predicate</code><dd>The argument is an alternate name for the predicate which recognizes
objects of this type.  The default is <var>name</var><code>-p</code>.  <code>nil</code>
means not to generate a predicate function.  (If the <code>:type</code>
option is used without the <code>:named</code> option, no predicate is
ever generated.)

          <p>In true Common Lisp, <code>typep</code> is always able to recognize a
structure object even if <code>:predicate</code> was used.  In this
package, <code>typep</code> simply looks for a function called
<var>typename</var><code>-p</code>, so it will work for structure types
only if they used the default predicate name.

          <br><dt><code>:include</code><dd>This option implements a very limited form of C++-style inheritance. 
The argument is the name of another structure type previously
created with <code>defstruct</code>.  The effect is to cause the new
structure type to inherit all of the included structure's slots
(plus, of course, any new slots described by this struct's slot
descriptors).  The new structure is considered a &ldquo;specialization&rdquo;
of the included one.  In fact, the predicate and slot accessors
for the included type will also accept objects of the new type.

          <p>If there are extra arguments to the <code>:include</code> option after
the included-structure name, these options are treated as replacement
slot descriptors for slots in the included structure, possibly with
modified default values.  Borrowing an example from Steele:

          <pre class="example">               (defstruct person name (age 0) sex)
                    &rArr; person
               (defstruct (astronaut (:include person (age 45)))
                 helmet-size
                 (favorite-beverage 'tang))
                    &rArr; astronaut
               
               (setq joe (make-person :name "Joe"))
                    &rArr; [cl-struct-person "Joe" 0 nil]
               (setq buzz (make-astronaut :name "Buzz"))
                    &rArr; [cl-struct-astronaut "Buzz" 45 nil nil tang]
               
               (list (person-p joe) (person-p buzz))
                    &rArr; (t t)
               (list (astronaut-p joe) (astronaut-p buzz))
                    &rArr; (nil t)
               
               (person-name buzz)
                    &rArr; "Buzz"
               (astronaut-name joe)
                    &rArr; error: "astronaut-name accessing a non-astronaut"
</pre>
          <p>Thus, if <code>astronaut</code> is a specialization of <code>person</code>,
then every <code>astronaut</code> is also a <code>person</code> (but not the
other way around).  Every <code>astronaut</code> includes all the slots
of a <code>person</code>, plus extra slots that are specific to
astronauts.  Operations that work on people (like <code>person-name</code>)
work on astronauts just like other people.

          <br><dt><code>:print-function</code><dd>In full Common Lisp, this option allows you to specify a function
which is called to print an instance of the structure type.  The
Emacs Lisp system offers no hooks into the Lisp printer which would
allow for such a feature, so this package simply ignores
<code>:print-function</code>.

          <br><dt><code>:type</code><dd>The argument should be one of the symbols <code>vector</code> or <code>list</code>. 
This tells which underlying Lisp data type should be used to implement
the new structure type.  Vectors are used by default, but
<code>(:type list)</code> will cause structure objects to be stored as
lists instead.

          <p>The vector representation for structure objects has the advantage
that all structure slots can be accessed quickly, although creating
vectors is a bit slower in Emacs Lisp.  Lists are easier to create,
but take a relatively long time accessing the later slots.

          <br><dt><code>:named</code><dd>This option, which takes no arguments, causes a characteristic &ldquo;tag&rdquo;
symbol to be stored at the front of the structure object.  Using
<code>:type</code> without also using <code>:named</code> will result in a
structure type stored as plain vectors or lists with no identifying
features.

          <p>The default, if you don't specify <code>:type</code> explicitly, is to
use named vectors.  Therefore, <code>:named</code> is only useful in
conjunction with <code>:type</code>.

          <pre class="example">               (defstruct (person1) name age sex)
               (defstruct (person2 (:type list) :named) name age sex)
               (defstruct (person3 (:type list)) name age sex)
               
               (setq p1 (make-person1))
                    &rArr; [cl-struct-person1 nil nil nil]
               (setq p2 (make-person2))
                    &rArr; (person2 nil nil nil)
               (setq p3 (make-person3))
                    &rArr; (nil nil nil)
               
               (person1-p p1)
                    &rArr; t
               (person2-p p2)
                    &rArr; t
               (person3-p p3)
                    &rArr; error: function person3-p undefined
</pre>
          <p>Since unnamed structures don't have tags, <code>defstruct</code> is not
able to make a useful predicate for recognizing them.  Also,
accessors like <code>person3-name</code> will be generated but they
will not be able to do any type checking.  The <code>person3-name</code>
function, for example, will simply be a synonym for <code>car</code> in
this case.  By contrast, <code>person2-name</code> is able to verify
that its argument is indeed a <code>person2</code> object before
proceeding.

          <br><dt><code>:initial-offset</code><dd>The argument must be a nonnegative integer.  It specifies a
number of slots to be left &ldquo;empty&rdquo; at the front of the
structure.  If the structure is named, the tag appears at the
specified position in the list or vector; otherwise, the first
slot appears at that position.  Earlier positions are filled
with <code>nil</code> by the constructors and ignored otherwise.  If
the type <code>:include</code>s another type, then <code>:initial-offset</code>
specifies a number of slots to be skipped between the last slot
of the included type and the first new slot. 
</dl>
        </p></blockquote></div>

   <p>Except as noted, the <code>defstruct</code> facility of this package is
entirely compatible with that of Common Lisp.

   </body></html>

