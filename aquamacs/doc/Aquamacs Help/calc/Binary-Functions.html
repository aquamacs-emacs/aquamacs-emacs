<html lang="en">
<head>
<title>Binary Functions - GNU Emacs Calc Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Emacs Calc Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Arithmetic.html#Arithmetic" title="Arithmetic">
<link rel="prev" href="Financial-Functions.html#Financial-Functions" title="Financial Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents Calc, the GNU Emacs calculator, included with GNU Emacs 23.1.

Copyright (C) 1990, 1991, 2001, 2002, 2003, 2004,
2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being just ``GNU GENERAL
     PUBLIC LICENSE'', with the Front-Cover texts being ``A GNU
     Manual,'' and with the Back-Cover Texts as in (a) below.  A copy
     of the license is included in the section entitled ``GNU Free
     Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Binary-Functions"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Financial-Functions.html#Financial-Functions">Financial Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Arithmetic.html#Arithmetic">Arithmetic</a>
<hr>
</div>

<h3 class="section">8.7 Binary Number Functions</h3>

<p class="noindent">The commands in this chapter all use two-letter sequences beginning with
the <kbd>b</kbd> prefix.

   <p><a name="index-Binary-numbers-922"></a>The &ldquo;binary&rdquo; operations actually work regardless of the currently
displayed radix, although their results make the most sense in a radix
like 2, 8, or 16 (as obtained by the <kbd>d 2</kbd>, <kbd>d 8</kbd>, or <kbd>d&nbsp;6</kbd><!-- /@w -->
commands, respectively).  You may also wish to enable display of leading
zeros with <kbd>d z</kbd>.  See <a href="Radix-Modes.html#Radix-Modes">Radix Modes</a>.

   <p><a name="index-Word-size-for-binary-operations-923"></a>The Calculator maintains a current <dfn>word size</dfn> &lsquo;<samp><span class="samp">w</span></samp>&rsquo;, an
arbitrary positive or negative integer.  For a positive word size, all
of the binary operations described here operate modulo &lsquo;<samp><span class="samp">2^w</span></samp>&rsquo;.  In
particular, negative arguments are converted to positive integers modulo
&lsquo;<samp><span class="samp">2^w</span></samp>&rsquo; by all binary functions.

   <p>If the word size is negative, binary operations produce twos-complement
integers from
<!-- @math{-2^{-w-1}} -->
&lsquo;<samp><span class="samp">-(2^(-w-1))</span></samp>&rsquo;
to
<!-- @math{2^{-w-1}-1} -->
&lsquo;<samp><span class="samp">2^(-w-1)-1</span></samp>&rsquo;
inclusive.  Either mode accepts inputs in any range; the sign of
&lsquo;<samp><span class="samp">w</span></samp>&rsquo; affects only the results produced.

   <p><a name="index-b-c-924"></a><a name="index-calc_002dclip-925"></a><a name="index-clip-926"></a>The <kbd>b c</kbd> (<code>calc-clip</code>)
[<code>clip</code>] command can be used to clip a number by reducing it modulo
&lsquo;<samp><span class="samp">2^w</span></samp>&rsquo;.  The commands described in this chapter automatically clip
their results to the current word size.  Note that other operations like
addition do not use the current word size, since integer addition
generally is not &ldquo;binary.&rdquo;  (However, see <a href="Simplification-Modes.html#Simplification-Modes">Simplification Modes</a>,
<code>calc-bin-simplify-mode</code>.)  For example, with a word size of 8
bits <kbd>b c</kbd> converts a number to the range 0 to 255; with a word
size of <i>-8</i> <kbd>b c</kbd> converts to the range <i>-128</i> to 127.

   <p><a name="index-b-w-927"></a><a name="index-calc_002dword_002dsize-928"></a>The default word size is 32 bits.  All operations except the shifts and
rotates allow you to specify a different word size for that one
operation by giving a numeric prefix argument:  <kbd>C-u 8 b c</kbd> clips the
top of stack to the range 0 to 255 regardless of the current word size. 
To set the word size permanently, use <kbd>b w</kbd> (<code>calc-word-size</code>). 
This command displays a prompt with the current word size; press &lt;RET&gt;
immediately to keep this word size, or type a new word size at the prompt.

   <p>When the binary operations are written in symbolic form, they take an
optional second (or third) word-size parameter.  When a formula like
&lsquo;<samp><span class="samp">and(a,b)</span></samp>&rsquo; is finally evaluated, the word size current at that time
will be used, but when &lsquo;<samp><span class="samp">and(a,b,-8)</span></samp>&rsquo; is evaluated, a word size of
<i>-8</i> will always be used.  A symbolic binary function will be left
in symbolic form unless the all of its argument(s) are integers or
integer-valued floats.

   <p>If either or both arguments are modulo forms for which &lsquo;<samp><span class="samp">M</span></samp>&rsquo; is a
power of two, that power of two is taken as the word size unless a
numeric prefix argument overrides it.  The current word size is never
consulted when modulo-power-of-two forms are involved.

   <p><a name="index-b-a-929"></a><a name="index-calc_002dand-930"></a><a name="index-and-931"></a>The <kbd>b a</kbd> (<code>calc-and</code>) [<code>and</code>] command computes the bitwise
AND of the two numbers on the top of the stack.  In other words, for each
of the &lsquo;<samp><span class="samp">w</span></samp>&rsquo; binary digits of the two numbers (pairwise), the corresponding
bit of the result is 1 if and only if both input bits are 1:
&lsquo;<samp><span class="samp">and(2#1100, 2#1010) = 2#1000</span></samp>&rsquo;.

   <p><a name="index-b-o-932"></a><a name="index-calc_002dor-933"></a><a name="index-or-934"></a>The <kbd>b o</kbd> (<code>calc-or</code>) [<code>or</code>] command computes the bitwise
inclusive OR of two numbers.  A bit is 1 if either of the input bits, or
both, are 1:  &lsquo;<samp><span class="samp">or(2#1100, 2#1010) = 2#1110</span></samp>&rsquo;.

   <p><a name="index-b-x-935"></a><a name="index-calc_002dxor-936"></a><a name="index-xor-937"></a>The <kbd>b x</kbd> (<code>calc-xor</code>) [<code>xor</code>] command computes the bitwise
exclusive OR of two numbers.  A bit is 1 if exactly one of the input bits
is 1:  &lsquo;<samp><span class="samp">xor(2#1100, 2#1010) = 2#0110</span></samp>&rsquo;.

   <p><a name="index-b-d-938"></a><a name="index-calc_002ddiff-939"></a><a name="index-diff-940"></a>The <kbd>b d</kbd> (<code>calc-diff</code>) [<code>diff</code>] command computes the bitwise
difference of two numbers; this is defined by &lsquo;<samp><span class="samp">diff(a,b) = and(a,not(b))</span></samp>&rsquo;,
so that &lsquo;<samp><span class="samp">diff(2#1100, 2#1010) = 2#0100</span></samp>&rsquo;.

   <p><a name="index-b-n-941"></a><a name="index-calc_002dnot-942"></a><a name="index-not-943"></a>The <kbd>b n</kbd> (<code>calc-not</code>) [<code>not</code>] command computes the bitwise
NOT of a number.  A bit is 1 if the input bit is 0 and vice-versa.

   <p><a name="index-b-l-944"></a><a name="index-calc_002dlshift_002dbinary-945"></a><a name="index-lsh-946"></a>The <kbd>b l</kbd> (<code>calc-lshift-binary</code>) [<code>lsh</code>] command shifts a
number left by one bit, or by the number of bits specified in the numeric
prefix argument.  A negative prefix argument performs a logical right shift,
in which zeros are shifted in on the left.  In symbolic form, &lsquo;<samp><span class="samp">lsh(a)</span></samp>&rsquo;
is short for &lsquo;<samp><span class="samp">lsh(a,1)</span></samp>&rsquo;, which in turn is short for &lsquo;<samp><span class="samp">lsh(a,n,w)</span></samp>&rsquo;. 
Bits shifted &ldquo;off the end,&rdquo; according to the current word size, are lost.

   <p><a name="index-H-b-l-947"></a><a name="index-H-b-r-948"></a><a name="index-H-b-L-949"></a><a name="index-H-b-R-950"></a><a name="index-H-b-t-951"></a>The <kbd>H b l</kbd> command also does a left shift, but it takes two arguments
from the stack (the value to shift, and, at top-of-stack, the number of
bits to shift).  This version interprets the prefix argument just like
the regular binary operations, i.e., as a word size.  The Hyperbolic flag
has a similar effect on the rest of the binary shift and rotate commands.

   <p><a name="index-b-r-952"></a><a name="index-calc_002drshift_002dbinary-953"></a><a name="index-rsh-954"></a>The <kbd>b r</kbd> (<code>calc-rshift-binary</code>) [<code>rsh</code>] command shifts a
number right by one bit, or by the number of bits specified in the numeric
prefix argument:  &lsquo;<samp><span class="samp">rsh(a,n) = lsh(a,-n)</span></samp>&rsquo;.

   <p><a name="index-b-L-955"></a><a name="index-calc_002dlshift_002darith-956"></a><a name="index-ash-957"></a>The <kbd>b L</kbd> (<code>calc-lshift-arith</code>) [<code>ash</code>] command shifts a
number left.  It is analogous to <code>lsh</code>, except that if the shift
is rightward (the prefix argument is negative), an arithmetic shift
is performed as described below.

   <p><a name="index-b-R-958"></a><a name="index-calc_002drshift_002darith-959"></a><a name="index-rash-960"></a>The <kbd>b R</kbd> (<code>calc-rshift-arith</code>) [<code>rash</code>] command performs
an &ldquo;arithmetic&rdquo; shift to the right, in which the leftmost bit (according
to the current word size) is duplicated rather than shifting in zeros. 
This corresponds to dividing by a power of two where the input is interpreted
as a signed, twos-complement number.  (The distinction between the &lsquo;<samp><span class="samp">rsh</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">rash</span></samp>&rsquo; operations is totally independent from whether the word
size is positive or negative.)  With a negative prefix argument, this
performs a standard left shift.

   <p><a name="index-b-t-961"></a><a name="index-calc_002drotate_002dbinary-962"></a><a name="index-rot-963"></a>The <kbd>b t</kbd> (<code>calc-rotate-binary</code>) [<code>rot</code>] command rotates a
number one bit to the left.  The leftmost bit (according to the current
word size) is dropped off the left and shifted in on the right.  With a
numeric prefix argument, the number is rotated that many bits to the left
or right.

   <p>See <a href="Set-Operations.html#Set-Operations">Set Operations</a>, for the <kbd>b p</kbd> and <kbd>b u</kbd> commands that
pack and unpack binary integers into sets.  (For example, <kbd>b u</kbd>
unpacks the number &lsquo;<samp><span class="samp">2#11001</span></samp>&rsquo; to the set of bit-numbers
&lsquo;<samp><span class="samp">[0, 3, 4]</span></samp>&rsquo;.)  Type <kbd>b u V #</kbd> to count the number of &ldquo;1&rdquo;
bits in a binary integer.

   <p>Another interesting use of the set representation of binary integers
is to reverse the bits in, say, a 32-bit integer.  Type <kbd>b u</kbd> to
unpack; type <kbd>31 &lt;TAB&gt; -</kbd> to replace each bit-number in the set
with 31 minus that bit-number; type <kbd>b p</kbd> to pack the set back
into a binary integer.

   </body></html>

