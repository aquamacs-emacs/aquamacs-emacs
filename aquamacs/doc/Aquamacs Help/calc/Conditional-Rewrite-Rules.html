<html lang="en">
<head>
<title>Conditional Rewrite Rules - GNU Emacs Calc Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Emacs Calc Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Rewrite-Rules.html#Rewrite-Rules" title="Rewrite Rules">
<link rel="prev" href="Basic-Rewrite-Rules.html#Basic-Rewrite-Rules" title="Basic Rewrite Rules">
<link rel="next" href="Algebraic-Properties-of-Rewrite-Rules.html#Algebraic-Properties-of-Rewrite-Rules" title="Algebraic Properties of Rewrite Rules">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents Calc, the GNU Emacs calculator, included with GNU Emacs 23.1.

Copyright (C) 1990, 1991, 2001, 2002, 2003, 2004,
2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being just ``GNU GENERAL
     PUBLIC LICENSE'', with the Front-Cover texts being ``A GNU
     Manual,'' and with the Back-Cover Texts as in (a) below.  A copy
     of the license is included in the section entitled ``GNU Free
     Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Conditional-Rewrite-Rules"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Algebraic-Properties-of-Rewrite-Rules.html#Algebraic-Properties-of-Rewrite-Rules">Algebraic Properties of Rewrite Rules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Basic-Rewrite-Rules.html#Basic-Rewrite-Rules">Basic Rewrite Rules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Rewrite-Rules.html#Rewrite-Rules">Rewrite Rules</a>
<hr>
</div>

<h4 class="subsection">11.11.3 Conditional Rewrite Rules</h4>

<p class="noindent">A rewrite rule can also be <dfn>conditional</dfn>, written in the form
&lsquo;<samp><var>old</var><span class="samp"> := </span><var>new</var><span class="samp"> :: </span><var>cond</var></samp>&rsquo;.  (There is also the obsolete
form &lsquo;<samp><span class="samp">[</span><var>old</var><span class="samp">, </span><var>new</var><span class="samp">, </span><var>cond</var><span class="samp">]</span></samp>&rsquo;.)  If a <var>cond</var> part
is present in the
rule, this is an additional condition that must be satisfied before
the rule is accepted.  Once <var>old</var> has been successfully matched
to the target expression, <var>cond</var> is evaluated (with all the
meta-variables substituted for the values they matched) and simplified
with <kbd>a s</kbd> (<code>calc-simplify</code>).  If the result is a nonzero
number or any other object known to be nonzero (see <a href="Declarations.html#Declarations">Declarations</a>),
the rule is accepted.  If the result is zero or if it is a symbolic
formula that is not known to be nonzero, the rule is rejected. 
See <a href="Logical-Operations.html#Logical-Operations">Logical Operations</a>, for a number of functions that return
1 or 0 according to the results of various tests.

   <p>For example, the formula &lsquo;<samp><span class="samp">n &gt; 0</span></samp>&rsquo; simplifies to 1 or 0 if &lsquo;<samp><span class="samp">n</span></samp>&rsquo;
is replaced by a positive or nonpositive number, respectively (or if
&lsquo;<samp><span class="samp">n</span></samp>&rsquo; has been declared to be positive or nonpositive).  Thus,
the rule &lsquo;<samp><span class="samp">f(x,y) := g(y+x,x) :: x+y &gt; 0</span></samp>&rsquo; would apply to
&lsquo;<samp><span class="samp">f(0, 4)</span></samp>&rsquo; but not to &lsquo;<samp><span class="samp">f(-3, 2)</span></samp>&rsquo; or &lsquo;<samp><span class="samp">f(12, a+1)</span></samp>&rsquo;
(assuming no outstanding declarations for &lsquo;<samp><span class="samp">a</span></samp>&rsquo;).  In the case of
&lsquo;<samp><span class="samp">f(-3, 2)</span></samp>&rsquo;, the condition can be shown not to be satisfied; in
the case of &lsquo;<samp><span class="samp">f(12, a+1)</span></samp>&rsquo;, the condition merely cannot be shown
to be satisfied, but that is enough to reject the rule.

   <p>While Calc will use declarations to reason about variables in the
formula being rewritten, declarations do not apply to meta-variables. 
For example, the rule &lsquo;<samp><span class="samp">f(a) := g(a+1)</span></samp>&rsquo; will match for any values
of &lsquo;<samp><span class="samp">a</span></samp>&rsquo;, such as complex numbers, vectors, or formulas, even if
&lsquo;<samp><span class="samp">a</span></samp>&rsquo; has been declared to be real or scalar.  If you want the
meta-variable &lsquo;<samp><span class="samp">a</span></samp>&rsquo; to match only literal real numbers, use
&lsquo;<samp><span class="samp">f(a) := g(a+1) :: real(a)</span></samp>&rsquo;.  If you want &lsquo;<samp><span class="samp">a</span></samp>&rsquo; to match only
reals and formulas which are provably real, use &lsquo;<samp><span class="samp">dreal(a)</span></samp>&rsquo; as
the condition.

   <p>The &lsquo;<samp><span class="samp">::</span></samp>&rsquo; operator is a shorthand for the <code>condition</code>
function; &lsquo;<samp><var>old</var><span class="samp"> := </span><var>new</var><span class="samp"> :: </span><var>cond</var></samp>&rsquo; is equivalent to
the formula &lsquo;<samp><span class="samp">condition(assign(</span><var>old</var><span class="samp">, </span><var>new</var><span class="samp">), </span><var>cond</var><span class="samp">)</span></samp>&rsquo;.

   <p>If you have several conditions, you can use &lsquo;<samp><span class="samp">... :: c1 :: c2 :: c3</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">... :: c1 &amp;&amp; c2 &amp;&amp; c3</span></samp>&rsquo;.  The two are entirely equivalent.

   <p>It is also possible to embed conditions inside the pattern:
&lsquo;<samp><span class="samp">f(x :: x&gt;0, y) := g(y+x, x)</span></samp>&rsquo;.  This is purely a notational
convenience, though; where a condition appears in a rule has no
effect on when it is tested.  The rewrite-rule compiler automatically
decides when it is best to test each condition while a rule is being
matched.

   <p>Certain conditions are handled as special cases by the rewrite rule
system and are tested very efficiently:  Where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is any
meta-variable, these conditions are &lsquo;<samp><span class="samp">integer(x)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">real(x)</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">constant(x)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">negative(x)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">x &gt;= y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">y</span></samp>&rsquo;
is either a constant or another meta-variable and &lsquo;<samp><span class="samp">&gt;=</span></samp>&rsquo; may be
replaced by any of the six relational operators, and &lsquo;<samp><span class="samp">x % a = b</span></samp>&rsquo;
where &lsquo;<samp><span class="samp">a</span></samp>&rsquo; and &lsquo;<samp><span class="samp">b</span></samp>&rsquo; are constants.  Other conditions, like
&lsquo;<samp><span class="samp">x &gt;= y+1</span></samp>&rsquo; or &lsquo;<samp><span class="samp">dreal(x)</span></samp>&rsquo;, will be less efficient to check
since Calc must bring the whole evaluator and simplifier into play.

   <p>An interesting property of &lsquo;<samp><span class="samp">::</span></samp>&rsquo; is that neither of its arguments
will be touched by Calc's default simplifications.  This is important
because conditions often are expressions that cannot safely be
evaluated early.  For example, the <code>typeof</code> function never
remains in symbolic form; entering &lsquo;<samp><span class="samp">typeof(a)</span></samp>&rsquo; will put the
number 100 (the type code for variables like &lsquo;<samp><span class="samp">a</span></samp>&rsquo;) on the stack. 
But putting the condition &lsquo;<samp><span class="samp">... :: typeof(a) = 6</span></samp>&rsquo; on the stack
is safe since &lsquo;<samp><span class="samp">::</span></samp>&rsquo; prevents the <code>typeof</code> from being
evaluated until the condition is actually used by the rewrite system.

   <p>Since &lsquo;<samp><span class="samp">::</span></samp>&rsquo; protects its lefthand side, too, you can use a dummy
condition to protect a rule that must itself not evaluate early. 
For example, it's not safe to put &lsquo;<samp><span class="samp">a(f,x) := apply(f, [x])</span></samp>&rsquo; on
the stack because it will immediately evaluate to &lsquo;<samp><span class="samp">a(f,x) := f(x)</span></samp>&rsquo;,
where the meta-variable-ness of <code>f</code> on the righthand side has been
lost.  But &lsquo;<samp><span class="samp">a(f,x) := apply(f, [x]) :: 1</span></samp>&rsquo; is safe, and of course
the condition &lsquo;<samp><span class="samp">1</span></samp>&rsquo; is always true (nonzero) so it has no effect on
the functioning of the rule.  (The rewrite compiler will ensure that
it doesn't even impact the speed of matching the rule.)

   </body></html>

